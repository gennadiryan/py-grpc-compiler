# Custom fork of gRPC Python Tools (grpcio-tools==1.50.0)

This is an experimental fork of `protoc` and the associated gRPC Python compiler `grpc_tools.protoc`.
The package is not intended for production but rather to provide a lightweight, self-contained environment from which to experiment with these packages.

The code generated by `grpc_tools.protoc --python_out` is dependent on `protobuf`, and the code generated by `grpc_tools.protoc --grpc_python_out` is dependent on `grpcio`. These packages are not strictly necessary for studying the code generator; it will generate code without any package available to run it. However, if they are not present in the local environment, it is recommended `setup.py` be allowed to install them, to enable testing the generated code's descriptor references for correctness.

The intention of this experimental fork is to investigate the possibility of parameterizing the module names of generated python code. The default code generator uses the relative paths of imported proto files to determine the imports to generate for python. For specific use cases these imports are well-formed, but are not flexible; moreover, there is ample evidence of a long-running incompatibility between standard python use cases and the imports generated by `grpc_tools.protoc`.

Other languages' code generators are well aware of the need for parameterization in this case. The C++ code generator mirrors proto file structure in the namespaces of generated code. Code generators for Go, Java, ObjectiveC, C#, and even PHP (!!??) explicitly recognize options to override the default namespace or class name, thus providing a means of generating code that can be predictably referenced.

Python use-cases on the other hand are hamstrung by the inability to do so, but also by the fact that top-level imports are rendered as `import [module_name]`. This means that in Python3, which deprecates implicit relative imports (a deprecation which was first announced in 2004), their validity as imports depends entirely on the `PYTHONPATH` containing `[module_name].py`, so that most use cases require housing the entrypoint python code in the same location. Many developers would prefer to be able to dump all `grpc_tools.protoc` outputs in a separate directory, not intermingled with the protos themselves, and certainly not intermingled with standard code and other package machinery.

There are a few possible approaches to address this with more flexibility:
- Explicit relative imports: this would entail the generated code importing other generated code explicitly by prefixing the top-level package name with the appropriate number of dots.
- Absolute imports: this would entail the understanding that all protos are to be dumped in a predetermined namespace package, and prefixing the module names with this top-level package to ensure that no imports can be interpreted as Python2-style implicit relative imports. The top-level package name would need to be in the PYTHONPATH of the environment running the generated code, which is a portable approach. A common package name for some set of generated code in a system encourages reuse of code. Several such packages could be referenced, allowing one to use proto package names (as defined by the `package [package_name]` directive) to refer to the corresponding package of generated code on the PYTHONPATH without namespace pollution or collisions.

There are some implementation challenges to achieve this. So far the `grpc_python_generator` has been reconfigured to accept command line arguments corresponding to `import_prefix` and `prefixes_to_filter`, which allow one to specify changes to the module name as it is computed from the proto filename. The arguments are provided like so:
`grpc_tools.protoc --grpc_python_out="[[import_prefix];[prefix_to_filter][(,prefix_to_filter)*]:]/path/to/grpc/python/out/"`.
The arguments are prefixed to the filename followed by a colon; the arguments themselves are a pair of semicolon-delimited statements (hence requiring quotes in the shell), the first of which is the optional `import_prefix` string, and the second of which is any number of optional comma-delimited `prefix_to_filter`.

This is sufficient to achieve absolute imports in a package among the `*_pb2_grpc.py` files; however, these files need to refer to `*_pb2.py` files, which do not have the same correction in place yet. Hence only in use cases where all messages are defined in the same `*_pb2.py` file would this work. In particular, the `python_generator` uses quite similar logic to resolve proto filenames to python package names, but does not have a built-in capability to add or strip prefixes, which thus remains to be added.

## Requirements

This fork groups a few distinct components from the gRPC and protobuf packages:

1. `third_party/protobuf/src/google/protobuf/`: This is the C++ `protoc` implementation, as shipped by gRPC in the top-level `third_party/protobuf/` folder of the repo (it is copied in here as would be in a build for convenience).
It implements `protoc`'s core functionality including the protobuf parser and the importer (which resolves references found by the parser) to produce the IDL representation of a proto file.
It also implements the interfaces for code generators and plugins, and the unified command line interface through which they are accessed.
In particular, the python code generator specific sources are in `third_party/protobuf/src/google/protobuf/compiler/python/`.
The `setup.py` for the python package copies `protoc`'s protos into `grpc_tools/_proto/google/protobuf/`.
These protos are used by the `protoc` implementation to construct IDL representations of protobuf objects such as file, message, enum, type, and service descriptors, among others.
This path should be in the proto path when using `protoc` (this is done automatically in the grpc_tools python wrapper, so is only a concern when using a `protoc` binary directly).
1. `grpc_root/src/compiler/` and `grpc_root/include/`: These are the source files for all of the gRPC code generators; in particular, the python code generator.
The generators implemented here are complementary to the proto generators implemented in `third_party`.
The gRPC generators are dependent on core `protoc` dependencies to read proto files and inherit from the `CodeGenerator` interface; however they are independent of the `protoc` language plugins.
The includes consist of each of `*.c`, `*.cc` (Linux), and `*.cpp` (Windows) compatible header files.
1. `grpc_tools/`: This is the core python interface exposing `protoc`'s python compiler and its gRPC python compiler as the `python -m grpc_tools.protoc` command-line tool.
This tool depends on the core `protoc` command line interface, as well as the python `protoc` language plugin (exposed via the `--python-out` argument).
However the dependency on the language plugin is superficial; the `grpc_python_generator` does not otherwise interact with the plugin or share a `GeneratorContext` instance.


## Local installation

```
python3 -m venv env
env/bin/pip install cython
GRPC_PYTHON_BUILD_WITH_CYTHON=1 env/bin/pip -vvv install -e .
```
